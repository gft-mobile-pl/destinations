# Destinations: type-safe multi-module navigation

Currently Google suggests using `routes` to define destinations in Compose enabled projects. 
Unfortunately `routes` based navigation has many limitations which cannot be easily mitigated and is generally a step back 
when compared to `xml` based navigation.

`Destinations` library aims to deliver a similar set of features as `xml` based solution while avoiding the pitfalls of `routes`. 

| Aspect                                            | Destinations                                                                                                                             | Routes                                                                                                                                     |
|---------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------|
| Type-safety                                       | ✔ Yes, compile-time.                                                                                                                     | ❌ No, crash at runtime.                                                                                                                    |
| Supported types                                   | ✔ Primitives, Parcelables, Serializables.                                                                                                | ❌ Primitives only.                                                                                                                         |
| Data classes as arguments                         | ✔ Yes (if they are Parcelable or Serializable).                                                                                          | ❌ No.                                                                                                                                      |
| Any number of arguments                           | ✔ Yes.<br/>⚠ Multiple arguments must be grouped in a single Parcelable or Serializable.                                                  | ✔ Yes.                                                                                                                                     |
| Order of arguments is important                   | ✔ No. You can use named arguments in any order.                                                                                          | ❌ Yes if you use `/slash/{syntax}/`<br/>✔ No if you use `?query={syntax}`.                                                                 |
| Arguments description is required                 | ✔ No. Common data classes or primitives serve as arguments.                                                                              | ❌ You need to provide a `NamedNavArgument`  for each parameter. Parameters will be typed to `String` otherwise.                            |
| Nullable arguments supported                      | ✔ Yes. You simply use nullable field (by adding `?`).                                                                                    | ❌ No if you use `/slash/{syntax}/`<br/>✔ Yes if you use `?query={syntax}`.                                                                 |
| Defining conflicting destinations possible        | ✔ No. Identifiers are generated automatically and cannot repeat.                                                                         | ❌ Yes. `routes` are just `Strings` created manually and there will be a runtime conflict if e.g. two feature modules use the same `route`. |
| Encapsulating destination in a sub-graph possible | ✔ Yes.                                                                                                                                   | ❌ No. Even if you place a destination in a sub-graph you can navigate to it directly as all `routes` are global.                           |
| Controlling destinations visibility possible      | ✔ Yes. You simply control the visibility of `Destination` objects in Kotlin (you can't navigate to a `Destination` without a reference). | ❌ No. You can always navigate to any destination if you know the `String` defining the `route` as all `routes` are global.                 |
| Deeplinks supported                               | ✔ Not required. You may define a deeplink as usual and redirect it to a `Destination` using `Side Effect`.                               | ✔ Yes.                                                                                                                                     |
| Annotation processor required                     | ✔ No.                                                                                                                                    | ✔ No.                                                                                                                                      |
| Reflection used                                   | ✔ No.                                                                                                                                    | ✔ No.                                                                                                                                      |
| Amount of boilerplate                             | ✔ Minimalistic API.                                                                                                                      | ❌ A lot of boilreplate is required to define and use arguments.                                                                            |


